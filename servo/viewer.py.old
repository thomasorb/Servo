import numpy as np
import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk
import csv
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import json
from pathlib import Path


from . import core
from . import config


class Viewer(core.Worker):
    """
    """

    def __init__(self, data, stop_event):
        super().__init__(data, stop_event)
        
        self.root = tk.Tk()
        self.root.title("IRCamera Viewer")

        

        # --- Initial size (choose one approach) ---
        # Fixed size:
        self.root.geometry("1280x800")
        self.root.minsize(900, 600)

        # sw = self.root.winfo_screenwidth()
        # sh = self.root.winfo_screenheight()
        # w = int(sw * 0.8); h = int(sh * 0.8)
        # x = (sw - w) // 2; y = (sh - h) // 2
        # self.root.geometry(f"{w}x{h}+{x}+{y}")

        # Optional: HiDPI tune (1.0 default)
        # self.root.tk.call("tk", "scaling", 1.0)

        
        # Load previous window size/position/state (if any)
        self.load_window_geometry()
        
        # When user closes the window, save geometry then exit
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)

        # Best font for Tk on Linux
        self.root.option_add("*Font", ("Noto Sans", 14))

        # Consistent scaling
        self.root.tk.call("tk", "scaling", 1.0)

        # Apply font to all ttk widgets
        style = ttk.Style(self.root)
        style.configure(".", font=("Noto Sans", 14))
        
        # Use "clam" theme for cleaner rendering
        style.theme_use("clam")

        # ----------------------------------
        # IMAGE DIMENSIONS
        # ----------------------------------
        self.img_w = self.data['IRCamera.frame_dimx'][0]
        self.img_h = self.data['IRCamera.frame_dimy'][0]

        # Initial float32 frame
        self.frame = self.generate_frame()

        # ----------------------------------
        # BRIGHTNESS / CONTRAST (DS9-style)
        # ----------------------------------
        self.brightness = 0.0       # vertical drag
        self.contrast = 1.0         # horizontal drag
        self.last_bc_mouse = None   # previous mouse during drag

        # ----------------------------------
        # LUT
        # ----------------------------------
        self.current_lut_name = "gray"
        self.lut = self.build_lut_gray()

        # ----------------------------------
        # CANVAS + IMAGE ITEM
        # ----------------------------------
        
        # --- Main container: left = canvas (expands), right = control panel ---
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Left: canvas
        self.canvas = tk.Canvas(main_frame, bg="black")
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # --- Right panel for piezo controls ---
        right_panel = ttk.Frame(main_frame)
        right_panel.pack(side=tk.RIGHT, fill=tk.Y, padx=6, pady=6)

        # LabelFrame for cleaner grouping
        piezos_frame = ttk.LabelFrame(right_panel, text="Piezos", padding=10)
        piezos_frame.pack(fill=tk.Y, expand=False)

        # Row containing the 3 scales side-by-side
        piezos_row = ttk.Frame(piezos_frame)
        piezos_row.pack(fill=tk.Y, expand=False)

        # Piezo control variables
        self.var_opd = tk.DoubleVar(value=0.0)
        self.var_da1 = tk.DoubleVar(value=0.0)
        self.var_da2 = tk.DoubleVar(value=0.0)

        # Initialize from shared memory if available
        try:
            init_vals = self.data.get("DAQ.piezos_level", None)
            if init_vals and len(init_vals) >= 3:
                self.var_opd.set(float(init_vals[0]))
                self.var_da1.set(float(init_vals[1]))
                self.var_da2.set(float(init_vals[2]))
        except Exception:
            pass


        def _build_scale(parent, label, var, col):
            """
            Build a vertical Scale centered in its own column,
            with the label ABOVE the scale.
            """
            col_frame = ttk.Frame(parent)
            col_frame.grid(row=0, column=col, padx=10, pady=5)

            # Label ABOVE the scale
            ttk.Label(col_frame, text=label).pack(pady=(0, 6))

            # Vertical Scale (0 → 10)
            scl = ttk.Scale(
                col_frame,
                from_=10.0, to=0.0,
                variable=var,
                orient=tk.VERTICAL,
                length=220,
                command=self._on_piezos_change,
            )
            scl.pack()

            return scl


        # Build 3 labeled scales horizontally
        self.scale_opd = _build_scale(piezos_row, "OPD", self.var_opd, col=0)
        self.scale_da1 = _build_scale(piezos_row, "DA-1", self.var_da1, col=1)
        self.scale_da2 = _build_scale(piezos_row, "DA-2", self.var_da2, col=2)

        # Initialize shared variable
        self._write_piezos_to_shared()


        self.root.after_idle(lambda: self.on_resize(None))

        self.tk_image = None
        self.image_id = None

        # ----------------------------------
        # ZOOM & PAN
        # ----------------------------------
        self.scale = 1.0
        self.offset_x = 0.0
        self.offset_y = 0.0
        self.fitted = False

        # ----------------------------------
        # OVERLAYS: crosshair, markers
        # ----------------------------------
        self.cross_h = self.canvas.create_line(0, 0, 0, 0, fill="yellow")
        self.cross_v = self.canvas.create_line(0, 0, 0, 0, fill="yellow")

        # Ensure crosshair stays above the image
        self.canvas.tag_raise(self.cross_h)
        self.canvas.tag_raise(self.cross_v)

        # Markers stored as (item_id, ix, iy) in image coords
        self.points = []

        # ----------------------------------
        # LINE PROFILE TOOL (SHIFT + Drag)
        # ----------------------------------
        self.profile_active = False
        self.profile_start = None       # canvas coords
        self.profile_line_id = None     # temporary overlay during drag

        # ----------------------------------
        # ROI TOOL (CTRL + Drag)
        # ----------------------------------
        self.roi_active = False
        self.roi_start_canvas = None    # canvas coords
        self.roi_rect_id = None         # canvas rectangle item
        self.roi_bounds_img = None      # (x0, y0, x1, y1) in image coords

        # ----------------------------------
        # MOUSE BINDINGS
        # ----------------------------------
        self.canvas.bind("<Configure>", self.on_resize)
        self.canvas.bind("<Motion>", self.on_mouse_move)

        # Dispatchers for left button modifiers (SHIFT/CTRL/None)
        self.canvas.bind("<ButtonPress-1>", self.on_left_press_dispatch)
        self.canvas.bind("<B1-Motion>", self.on_left_motion_dispatch)
        self.canvas.bind("<ButtonRelease-1>", self.on_left_release_dispatch)

        # Right-button drag → brightness/contrast
        self.canvas.bind("<ButtonPress-3>", self.bc_start)
        self.canvas.bind("<B3-Motion>", self.bc_drag)
        self.canvas.bind("<ButtonRelease-3>", self.bc_end)

        # Linux scroll → zoom
        self.canvas.bind("<Button-4>", lambda e: self.zoom_at(e.x, e.y, 1.1))
        self.canvas.bind("<Button-5>", lambda e: self.zoom_at(e.x, e.y, 0.9))

        # ----------------------------------
        # TOOLBAR (below canvas)
        # ----------------------------------
        toolbar = ttk.Frame(self.root)
        toolbar.pack(fill=tk.X, pady=3)

        ttk.Label(toolbar, text="LUT:").pack(side=tk.LEFT, padx=5)

        self.lut_var = tk.StringVar(value="gray")
        lut_choices = ["gray", "viridis", "inferno", "magma", "plasma", "cividis", "turbo", "rainbow"]

        self.lut_menu = ttk.Combobox(toolbar, textvariable=self.lut_var, values=lut_choices,
                                     state="readonly", width=10)
        self.lut_menu.pack(side=tk.LEFT, padx=5)
        self.lut_menu.bind("<<ComboboxSelected>>", self.on_lut_changed)

        # Histogram toggle
        self.hist_btn = ttk.Button(toolbar, text="Show Histogram", command=self.toggle_histogram)
        self.hist_btn.pack(side=tk.RIGHT, padx=10)

        # Reset zoom
        self.reset_btn = ttk.Button(toolbar, text="Reset Zoom", command=self.reset_zoom)
        self.reset_btn.pack(side=tk.RIGHT, padx=10)

        # Clear ROI
        self.clear_roi_btn = ttk.Button(toolbar, text="Clear ROI", command=self.clear_roi)
        self.clear_roi_btn.pack(side=tk.RIGHT, padx=10)

        # Export
        self.export_btn = ttk.Button(toolbar, text="Export PNG", command=self.export_png)
        self.export_btn.pack(side=tk.RIGHT, padx=10)


        # ----------------------------------
        # INFO PANEL (position/value + ROI stats)
        # ----------------------------------
        info = ttk.Frame(self.root, height=30)
        info.pack(fill=tk.X, pady=3)
        info.pack_propagate(False)

        ttk.Label(info, text="Position:").pack(side=tk.LEFT)
        self.pos_var = tk.StringVar(value="x = —, y = —")
        ttk.Label(info, textvariable=self.pos_var).pack(side=tk.LEFT, padx=5)

        ttk.Label(info, text="Value:").pack(side=tk.LEFT)
        self.val_var = tk.StringVar(value="—")
        ttk.Label(info, textvariable=self.val_var).pack(side=tk.LEFT, padx=5)

        self.roi_stats_var = tk.StringVar(value="ROI: none")
        ttk.Label(info, textvariable=self.roi_stats_var, foreground="#5FA8FF").pack(side=tk.RIGHT, padx=10)

        # ----------------------------------
        # CSV LOGGING
        # ----------------------------------
        self.csv_file = "clicks.csv"
        self.ensure_csv_header()

        # ----------------------------------
        # HISTOGRAM WINDOW
        # ----------------------------------
        self.hist_window = None
        self.hist_canvas = None
        self.hist_fig = None
        self.hist_ax = None

        # ----------------------------------
        # PERIODIC REFRESH
        # ----------------------------------
        self.root.after(100, self.refresh)

        # For normal click detection (no modifiers)
        self._normal_click_start = None

    def run(self):
        self.root.mainloop()

    # ==============================================================
    # FRAME ACQUISITION
    # ==============================================================

    def generate_frame(self):
        """Dummy initial frame."""
        return np.random.rand(self.img_h, self.img_w).astype(np.float32)

    # ==============================================================
    # LUT BUILDERS
    # ==============================================================

    def build_lut_gray(self):
        lut = np.linspace(0, 1, 256)
        lut = np.stack([lut, lut, lut], axis=1)
        return lut

    def build_lut_viridis(self):
        from matplotlib import cm
        cmap = cm.get_cmap("viridis", 256)
        return cmap(np.linspace(0, 1, 256))[:, :3]

    def build_lut_inferno(self):
        from matplotlib import cm
        cmap = cm.get_cmap("inferno", 256)
        return cmap(np.linspace(0, 1, 256))[:, :3]

    def build_lut_magma(self):
        from matplotlib import cm
        cmap = cm.get_cmap("magma", 256)
        return cmap(np.linspace(0, 1, 256))[:, :3]

    def build_lut_plasma(self):
        from matplotlib import cm
        cmap = cm.get_cmap("plasma", 256)
        return cmap(np.linspace(0, 1, 256))[:, :3]

    def build_lut_cividis(self):
        from matplotlib import cm
        cmap = cm.get_cmap("cividis", 256)
        return cmap(np.linspace(0, 1, 256))[:, :3]

    def build_lut_turbo(self):
        from matplotlib import cm
        cmap = cm.get_cmap("turbo", 256)
        return cmap(np.linspace(0, 1, 256))[:, :3]

    def build_lut_rainbow(self):
        from matplotlib import cm
        cmap = cm.get_cmap("rainbow", 256)
        return cmap(np.linspace(0, 1, 256))[:, :3]

    def on_lut_changed(self, event=None):
        name = self.lut_var.get()
        if   name == "gray":     self.lut = self.build_lut_gray()
        elif name == "viridis":  self.lut = self.build_lut_viridis()
        elif name == "inferno":  self.lut = self.build_lut_inferno()
        elif name == "magma":    self.lut = self.build_lut_magma()
        elif name == "plasma":   self.lut = self.build_lut_plasma()
        elif name == "cividis":  self.lut = self.build_lut_cividis()
        elif name == "turbo":    self.lut = self.build_lut_turbo()
        elif name == "rainbow":  self.lut = self.build_lut_rainbow()
        self.render()
        self.update_histogram()

    # ==============================================================
    # BRIGHTNESS / CONTRAST (DS9-style)
    # ==============================================================

    def bc_start(self, event):
        self.last_bc_mouse = (event.x, event.y)

    def bc_drag(self, event):
        if self.last_bc_mouse is None:
            return
        dx = event.x - self.last_bc_mouse[0]
        dy = event.y - self.last_bc_mouse[1]
        # DS9-like mapping
        self.brightness += dy * 0.002
        self.contrast   *= (1.0 + dx * 0.002)
        self.contrast    = max(0.05, min(self.contrast, 5.0))
        self.last_bc_mouse = (event.x, event.y)
        self.render()
        self.update_histogram()

    def bc_end(self, event):
        self.last_bc_mouse = None

    # ==============================================================
    # NORMALIZATION + LUT
    # ==============================================================

    def stretch_frame(self, frame):
        """Apply brightness and contrast to float32 frame."""
        fmin = frame.min()
        fmax = frame.max()
        if fmax <= fmin:
            return np.zeros_like(frame)
        norm = (frame - fmin) / (fmax - fmin)
        norm = (norm - 0.5) * self.contrast + 0.5 + self.brightness
        norm = np.clip(norm, 0, 1)
        return norm

    def apply_lut(self, stretched):
        """Map stretched [0..1] to RGB via current LUT."""
        idx = (stretched * 255).astype(np.uint8)
        rgb = self.lut[idx]
        return (rgb * 255).astype(np.uint8)

    # ==============================================================
    # RENDERING
    # ==============================================================

    def render(self):
        """Render the image and all overlays."""
        stretched = self.stretch_frame(self.frame)
        rgb = self.apply_lut(stretched)

        disp_w = int(self.img_w * self.scale)
        disp_h = int(self.img_h * self.scale)

        pil_img = Image.fromarray(rgb, mode="RGB").resize((disp_w, disp_h), Image.NEAREST)
        self.tk_image = ImageTk.PhotoImage(pil_img)

        if self.image_id is None:
            self.image_id = self.canvas.create_image(self.offset_x, self.offset_y, anchor="nw", image=self.tk_image)
        else:
            self.canvas.itemconfig(self.image_id, image=self.tk_image)
            self.canvas.coords(self.image_id, self.offset_x, self.offset_y)

        # --- Reposition ROI rectangle overlay, if present ---
        if self.roi_bounds_img is not None:
            x0, y0, x1, y1 = self.roi_bounds_img
            cx0, cy0 = self.image_to_canvas(x0, y0)
            cx1, cy1 = self.image_to_canvas(x1, y1)
            if self.roi_rect_id is None:
                self.roi_rect_id = self.canvas.create_rectangle(cx0, cy0, cx1, cy1, outline="#5FA8FF", width=2)
            else:
                self.canvas.coords(self.roi_rect_id, cx0, cy0, cx1, cy1)

        # --- Reposition markers to follow zoom/pan ---
        r = 4  # screen pixels
        for item_id, ix, iy in self.points:
            cx, cy = self.image_to_canvas(ix, iy)
            self.canvas.coords(item_id, cx - r, cy - r, cx + r, cy + r)

        
        self.canvas.tag_raise(self.cross_h)
        self.canvas.tag_raise(self.cross_v)


    # ==============================================================
    # ZOOM & PAN
    # ==============================================================

    def on_resize(self, event):
        """Fit to window once at startup or when reset_zoom triggers."""
        if not self.fitted:
            cw = self.canvas.winfo_width()
            ch = self.canvas.winfo_height()
            if cw <= 1 or ch <= 1:
                return
            self.scale = min(cw / self.img_w, ch / self.img_h)
            self.offset_x = (cw - self.img_w * self.scale) / 2
            self.offset_y = (ch - self.img_h * self.scale) / 2
            self.fitted = True
            self.render()

    def reset_zoom(self):
        self.fitted = False
        self.on_resize(None)

    def zoom_at(self, cx, cy, factor):
        old_scale = self.scale
        new_scale = max(0.1, min(50.0, old_scale * factor))
        if new_scale == old_scale:
            return
        # Keep the point under the cursor stationary
        ix = (cx - self.offset_x) / old_scale
        iy = (cy - self.offset_y) / old_scale
        self.scale = new_scale
        self.offset_x = cx - ix * new_scale
        self.offset_y = cy - iy * new_scale
        self.render()

    # ==============================================================
    # COORDINATE TRANSFORMS
    # ==============================================================

    def canvas_to_image(self, cx, cy):
        ix = int((cx - self.offset_x) / self.scale)
        iy = int((cy - self.offset_y) / self.scale)
        return ix, iy

    def image_to_canvas(self, ix, iy):
        cx = ix * self.scale + self.offset_x
        cy = iy * self.scale + self.offset_y
        return cx, cy

    # ==============================================================
    # CROSSHAIR & POSITION READOUT
    # ==============================================================

    def on_mouse_move(self, event):
        ix, iy = self.canvas_to_image(event.x, event.y)
        if 0 <= ix < self.img_w and 0 <= iy < self.img_h:
            self.pos_var.set(f"x = {ix}, y = {iy}")
            self.val_var.set(f"{float(self.frame[iy, ix]):.3f}")
        else:
            self.pos_var.set("x = —, y = —")
            self.val_var.set("—")

        # Crosshair follows mouse in canvas coords
        self.canvas.coords(self.cross_h, 0, event.y, self.canvas.winfo_width(), event.y)
        self.canvas.coords(self.cross_v, event.x, 0, event.x, self.canvas.winfo_height())

    # ==============================================================
    # LEFT BUTTON DISPATCH (SHIFT: profile, CTRL: ROI, NONE: click marker)
    # ==============================================================

    def on_left_press_dispatch(self, event):
        # Linux modifier masks: SHIFT=0x0001, CTRL=0x0004 (these may vary per platform)
        if event.state & 0x0001:
            # SHIFT → profile start
            self.profile_start_event(event)
        elif event.state & 0x0004:
            # CTRL → ROI start
            self.roi_start_event(event)
        else:
            # Regular click: remember start (to avoid conflicting with drags)
            self._normal_click_start = (event.x, event.y)

    def on_left_motion_dispatch(self, event):
        if event.state & 0x0001:
            self.profile_drag_event(event)
        elif event.state & 0x0004:
            self.roi_drag_event(event)
        else:
            # Normal click does not drag a shape
            pass

    def on_left_release_dispatch(self, event):
        if self.profile_active:
            self.profile_end_event(event)
            return
        if self.roi_active:
            self.roi_end_event(event)
            return

        
        # Normal click: drop ONLY ONE marker + save to CSV
        if self._normal_click_start is not None:
            ix, iy = self.canvas_to_image(event.x, event.y)

            if 0 <= ix < self.img_w and 0 <= iy < self.img_h:
                val = float(self.frame[iy, ix])
                self.save_click(ix, iy, val)

                # Delete all old markers
                for item_id, _, _ in self.points:
                    self.canvas.delete(item_id)
                    self.points.clear()

                # Add the new one
                r = 4
                cx, cy = event.x, event.y
                p = self.canvas.create_oval(cx - r, cy - r, cx + r, cy + r,
                                            fill="red", outline="")
                self.points.append((p, ix, iy))

        self._normal_click_start = None


    # ==============================================================
    # LINE PROFILE TOOL (SHIFT + Drag)
    # ==============================================================

    def profile_start_event(self, event):
        """Start line profile if SHIFT is held."""
        # Verify inside image
        ix, iy = self.canvas_to_image(event.x, event.y)
        if not (0 <= ix < self.img_w and 0 <= iy < self.img_h):
            return
        self.profile_active = True
        self.profile_start = (event.x, event.y)
        # Remove previous preview line
        if self.profile_line_id is not None:
            self.canvas.delete(self.profile_line_id)
            self.profile_line_id = None

    def profile_drag_event(self, event):
        """Update temporary line overlay as user drags."""
        if not self.profile_active:
            return
        if self.profile_line_id is not None:
            self.canvas.delete(self.profile_line_id)
        self.profile_line_id = self.canvas.create_line(
            self.profile_start[0], self.profile_start[1], event.x, event.y, fill="cyan", width=2
        )

    def profile_end_event(self, event):
        """Compute line profile when SHIFT drag ends, then plot."""
        if not self.profile_active:
            return
        self.profile_active = False
        if self.profile_line_id is None:
            return
        # Convert endpoints to image coords
        x0, y0 = self.profile_start
        x1, y1 = event.x, event.y
        ix0, iy0 = self.canvas_to_image(x0, y0)
        ix1, iy1 = self.canvas_to_image(x1, y1)
        if not (0 <= ix0 < self.img_w and 0 <= iy0 < self.img_h): return
        if not (0 <= ix1 < self.img_w and 0 <= iy1 < self.img_h): return
        # Compute & show profile
        profile = self.compute_line_profile(ix0, iy0, ix1, iy1)
        self.show_profile_window(profile)
        # Remove the preview line to avoid stale overlay after zoom/pan
        self.canvas.delete(self.profile_line_id)
        self.profile_line_id = None

    def compute_line_profile(self, x0, y0, x1, y1):
        """Sample float32 frame along a line using bilinear interpolation."""
        length = int(np.hypot(x1 - x0, y1 - y0))
        if length < 2:
            return np.array([])
        xs = np.linspace(x0, x1, length)
        ys = np.linspace(y0, y1, length)
        xs = np.clip(xs, 0, self.img_w - 1)
        ys = np.clip(ys, 0, self.img_h - 1)

        vals = []
        for x, y in zip(xs, ys):
            x0i = int(np.floor(x)); x1i = min(x0i + 1, self.img_w - 1)
            y0i = int(np.floor(y)); y1i = min(y0i + 1, self.img_h - 1)
            dx = x - x0i; dy = y - y0i
            v00 = self.frame[y0i, x0i]; v10 = self.frame[y0i, x1i]
            v01 = self.frame[y1i, x0i]; v11 = self.frame[y1i, x1i]
            top = v00 * (1 - dx) + v10 * dx
            bottom = v01 * (1 - dx) + v11 * dx
            vals.append(top * (1 - dy) + bottom * dy)

        return np.array(vals, dtype=np.float32)

    def show_profile_window(self, profile):
        """Open a matplotlib window showing intensity profile."""
        if profile.size == 0:
            return
        fig = plt.figure(figsize=(6, 3))
        ax = fig.add_subplot(111)
        ax.plot(profile, color="cyan")
        ax.set_title("Line Profile")
        ax.set_xlabel("Distance (pixels)")
        ax.set_ylabel("Intensity")
        ax.grid(alpha=0.3)
        fig.tight_layout()
        fig.show()

    # ==============================================================
    # ROI TOOL (CTRL + Drag)
    # ==============================================================

    def roi_start_event(self, event):
        """Begin ROI rectangle drag (CTRL held)."""
        ix, iy = self.canvas_to_image(event.x, event.y)
        if not (0 <= ix < self.img_w and 0 <= iy < self.img_h):
            return
        self.roi_active = True
        self.roi_start_canvas = (event.x, event.y)
        if self.roi_rect_id is not None:
            self.canvas.delete(self.roi_rect_id)
            self.roi_rect_id = None
        self.roi_bounds_img = None
        self.roi_stats_var.set("ROI: drawing…")

    def roi_drag_event(self, event):
        """Update ROI rectangle preview."""
        if not self.roi_active:
            return
        x0, y0 = self.roi_start_canvas
        x1, y1 = event.x, event.y
        # Draw/replace preview rectangle in canvas coords
        if self.roi_rect_id is not None:
            self.canvas.coords(self.roi_rect_id, x0, y0, x1, y1)
        else:
            self.roi_rect_id = self.canvas.create_rectangle(x0, y0, x1, y1, outline="#5FA8FF", width=2)

    def roi_end_event(self, event):
        """Finalize ROI, compute stats & store bounds in image coords."""
        if not self.roi_active:
            return
        self.roi_active = False
        if self.roi_rect_id is None:
            self.roi_stats_var.set("ROI: none")
            return

        # Convert final corners to image coords
        cx0, cy0 = self.roi_start_canvas
        cx1, cy1 = event.x, event.y
        ix0, iy0 = self.canvas_to_image(cx0, cy0)
        ix1, iy1 = self.canvas_to_image(cx1, cy1)

        # Normalize ordering & clamp
        x0, x1 = sorted((max(0, ix0), min(self.img_w - 1, ix1)))
        y0, y1 = sorted((max(0, iy0), min(self.img_h - 1, iy1)))

        # Avoid zero-area
        if x1 <= x0 or y1 <= y0:
            self.clear_roi()
            return

        # Store ROI in image coords and update overlay via render()
        self.roi_bounds_img = (x0, y0, x1, y1)
        self.render()  # reprojects rectangle to canvas coords

        # Compute stats
        roi = self.frame[y0:y1, x0:x1]
        count = roi.size
        vmin = float(np.min(roi))
        vmax = float(np.max(roi))
        vmean = float(np.mean(roi))
        vstd = float(np.std(roi))

        self.roi_stats_var.set(f"ROI: {x1 - x0}×{y1 - y0} | min={vmin:.3f} max={vmax:.3f} "
                               f"mean={vmean:.3f} std={vstd:.3f} n={count}")

        # Update histogram overlay
        self.update_histogram()

    def clear_roi(self):
        """Remove ROI overlay and stats."""
        if self.roi_rect_id is not None:
            self.canvas.delete(self.roi_rect_id)
            self.roi_rect_id = None
        self.roi_bounds_img = None
        self.roi_stats_var.set("ROI: none")
        self.update_histogram()

    # ==============================================================
    # CSV LOGGING
    # ==============================================================

    def ensure_csv_header(self):
        try:
            with open(self.csv_file, "x", newline="", encoding="utf-8") as f:
                csv.writer(f).writerow(["x", "y", "value"])
        except FileExistsError:
            pass

    def save_click(self, x, y, value):
        with open(self.csv_file, "a", newline="", encoding="utf-8") as f:
            csv.writer(f).writerow([x, y, value])

    # ==============================================================
    # HISTOGRAM WINDOW
    # ==============================================================

    def toggle_histogram(self):
        if self.hist_window is None:
            self.open_histogram()
        else:
            self.close_histogram()

    def open_histogram(self):
        self.hist_window = tk.Toplevel(self.root)
        self.hist_window.title("Histogram")

        # matplotlib figure
        self.hist_fig = plt.Figure(figsize=(4.5, 3.2), dpi=100)
        self.hist_ax = self.hist_fig.add_subplot(111)
        self.hist_canvas = FigureCanvasTkAgg(self.hist_fig, master=self.hist_window)
        self.hist_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        self.update_histogram()

    def close_histogram(self):
        if self.hist_window:
            self.hist_window.destroy()
            self.hist_window = None

    def update_histogram(self):
        """Recompute histogram (full + optional ROI) if window is visible."""
        if self.hist_window is None:
            return

        self.hist_ax.clear()

        # Full image histogram (white)
        data = self.frame.flatten()        
        self.hist_ax.hist(data, bins=100, color="white", alpha=0.9,
                          label="Image", density=True)


        # ROI histogram (blue), if any
        if self.roi_bounds_img is not None:
            x0, y0, x1, y1 = self.roi_bounds_img
            roi = self.frame[y0:y1, x0:x1].flatten()
            if roi.size > 0:
                self.hist_ax.hist(roi, bins=100, color="#5FA8FF", alpha=0.6,
                                  label="ROI", density=True)


        self.hist_ax.set_title("Histogram")
        self.hist_ax.set_xlabel("Pixel Value")
        self.hist_ax.set_ylabel("Count")
        self.hist_ax.grid(True, alpha=0.3)
        self.hist_ax.legend(loc="upper right")

        self.hist_canvas.draw()

    
    # ==============================================================
    # EXPORT VIEW AS PNG (with overlays)
    # ==============================================================

    def export_png(self):
        """Export the current canvas (image + overlays) to a PNG file."""

        # Update canvas before export (to ensure everything is drawn)
        self.canvas.update()

        # Get canvas size
        w = self.canvas.winfo_width()
        h = self.canvas.winfo_height()

        # Generate PostScript (vector) snapshot of the canvas
        ps = self.canvas.postscript(colormode='color')

        # Convert PS to PIL
        from PIL import Image
        import io

        img = Image.open(io.BytesIO(ps.encode('utf-8')))

        # Crop to canvas size
        img = img.crop((0, 0, w, h))

        # Save PNG
        filename = "export_view.png"
        img.save(filename)

        print(f"Exported view to {filename}")



    # ==============================================================
    # WINDOW GEOMETRY PERSISTENCE
    # ==============================================================

    def _state_path(self):
        """
        Return the JSON path for saving window state.
        Uses ~/.config/<appname>/viewer_state.json on Linux, falls back to local file.
        """
        try:
            base = Path.home() / ".config" / "scientific_viewer"
            base.mkdir(parents=True, exist_ok=True)
            return base / "viewer_state.json"
        except Exception:
            return Path("viewer_state.json")

    def load_window_geometry(self):
        """
        Restore window geometry and state if previously saved.
        Falls back gracefully if file is missing or invalid.
        """
        p = self._state_path()
        if not p.exists():
            return  # nothing to restore

        try:
            data = json.loads(p.read_text())
        except Exception:
            return

        geom = data.get("geometry")
        state = data.get("state", "normal")

        # Ensure we apply geometry only if it looks valid like "1280x800+100+60"
        if isinstance(geom, str) and "x" in geom and "+" in geom:
            # Validate geometry vs. current screen to avoid off-screen windows
            sw = self.root.winfo_screenwidth()
            sh = self.root.winfo_screenheight()
            try:
                # Parse WxH+X+Y
                size_part, pos_part = geom.split("+", 1)
                w_str, h_str = size_part.split("x", 1)
                x_str, y_str = pos_part.split("+", 1)
                w = max(200, min(int(w_str), sw))   # clamp width
                h = max(150, min(int(h_str), sh))   # clamp height
                x = max(0, min(int(x_str), sw - 50))
                y = max(0, min(int(y_str), sh - 50))
                self.root.geometry(f"{w}x{h}+{x}+{y}")
            except Exception:
                # If parsing fails, just set the string directly (Tk may still accept it)
                self.root.geometry(geom)

        # Apply state (normal/zoomed) after a small delay so WM honors it
        def _apply_state():
            try:
                if state == "zoomed":
                    # Cross-platform attempts: Tk state('zoomed') works on Windows, many Linux WMs
                    self.root.state("zoomed")
                else:
                    self.root.state("normal")
            except Exception:
                pass

        self.root.after_idle(_apply_state)

    def save_window_geometry(self):
        """
        Save current window geometry and state to JSON.
        Called on exit (WM_DELETE_WINDOW).
        """
        # If window is zoomed/maximized, store that; otherwise store full geometry
        try:
            state = self.root.state()  # 'normal', 'iconic', 'zoomed'
        except Exception:
            state = "normal"

        # For zoomed we still record the last 'normal' geometry if available
        if state == "zoomed":
            # On some platforms, 'geometry()' returns the normal size when zoomed—good enough.
            geom = self.root.geometry()
            save = {"geometry": geom, "state": "zoomed"}
        else:
            geom = self.root.geometry()
            save = {"geometry": geom, "state": "normal"}

        p = self._state_path()
        try:
            p.parent.mkdir(parents=True, exist_ok=True)
            p.write_text(json.dumps(save, indent=2))
        except Exception:
            # As a last resort, try current directory
            try:
                Path("viewer_state.json").write_text(json.dumps(save, indent=2))
            except Exception:
                pass

    def on_close(self):
        """Graceful shutdown hook to save geometry, then quit."""
        try:
            self.save_window_geometry()
        finally:
            self.root.destroy()
            
    def _write_piezos_to_shared(self):
        """Write current Scale values to shared data as a 3-float list."""
        vals = [float(self.var_opd.get()), float(self.var_da1.get()), float(self.var_da2.get())]
        self.data['DAQ.piezos_level'][:3] = np.array(vals, dtype=config.DAQ_PIEZO_LEVELS_DTYPE)

    def _on_piezos_change(self, *_):
        """Scale callback: whenever one changes, push all three to shared data."""
        self._write_piezos_to_shared()

    # ==============================================================
    # REFRESH LOOP
    # ==============================================================

    def refresh(self):
        """Refresh from shared memory and update image & histogram."""
        raw = self.data['IRCamera.last_frame'][:self.data['IRCamera.frame_size'][0]]
        new_frame = np.array(raw).reshape((self.img_w, self.img_h)).T
        self.frame = new_frame
        self.render()
        self.update_histogram()
        self.root.after(100, self.refresh)
