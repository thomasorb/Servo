import os
import sys
import numpy as np
import time
import logging
import multiprocessing

import NITLibrary_x64_382_py312 as NITLibrary

import core
import config

# import logging
# logger = logging.getLogger(__name__)
# logging.basicConfig(filename='servo.log', level=logging.DEBUG,
#                     format='%(relativeCreated)6d %(threadName)s %(asctime)s %(name)-12s %(levelname)-8s %(message)s')

global logger
logger = logging.getLogger(__name__)

class IRCamera(core.Worker):

    def __init__(self, data, roi_shape=None, roi_center=None):
        
        super().__init__(data)
        
        if roi_shape is None:
            self.roi_shape = np.array(config.FULL_FRAME_SHAPE)
            
        if roi_center is None:
            self.roi_position = np.array(config.DEFAULT_ROI_POSITION)
        else:
            self.roi_position = np.array(roi_center) - roi_shape//2
            
        assert (0 <= self.roi_position[0] < config.FULL_FRAME_SHAPE[0]), f'bad x position: {self.roi_position[0]}'
        assert (0 <= self.roi_position[1] < config.FULL_FRAME_SHAPE[1]), f'bad y position: {self.roi_position[1]}'

        assert (config.MIN_ROI_SHAPE <= self.roi_shape[0] <= config.FULL_FRAME_SHAPE[0]), f'bad shape: {self.roi_shape[0]}'
        assert (config.MIN_ROI_SHAPE <= self.roi_shape[1] <= config.FULL_FRAME_SHAPE[1]), f'bad shape: {self.roi_shape[1]}'

        logger.info(f'target ROI {self.roi_shape} at {self.roi_position}')

        self.roi_size = np.prod(self.roi_shape)
        
        self.data = data
        
        self.nm = NITLibrary.NITManager.getInstance() #Get unique instance of NITManager
        logger.info(self.nm.listDevices())
        self.dev = self.nm.openOneDevice()
        assert self.dev is not None, logger.error("IR Camera not connected")


        self.config_obs = ConfigObserver()
        self.dev << self.config_obs
        
        # Device Configuration

        # #Get param value (2 ways)
        # print("Exposure:" + self.dev.paramStrValueOf( "Exposure Time" ) )
        # print("PixelClock:" + str( self.dev.paramValueOf( "Pixel Clock" ) ) )
        # #print("PixelDepth: " + self.dev.paramStrValueOf( NITLibrary.NITCatalog.PIX_DEPTH ))


        # Set params value
        self.dev.updateConfig()
        self.dev.setParamValueOf("Mode", "High Speed").updateConfig()
        
        self.dev.setParamValueOf("Number Of Columns", int(self.roi_shape[0]))
        self.dev.setParamValueOf("Number Of Lines", int(self.roi_shape[1]))
        self.dev.setParamValueOf("First Column", int(self.roi_position[0]))
        self.dev.setParamValueOf("First Line", int(self.roi_position[1]))
        
        self.dev.setParamValueOf("ExposureTime", "10us" )
        self.dev.updateConfig()

        # Fps configuration: set fps to a mean value
        min_fps = self.dev.minFps()
        max_fps = self.dev.maxFps()
        logger.info(f"fps range: ({self.dev.minFps()} - {self.dev.maxFps()})")
        self.dev.setFps(max_fps)
        self.dev.updateConfig()  #Data is sent to the device
        logger.info(f"current fps: {self.dev.fps()}")

        # Set pipeline 
        self.agc = NITLibrary.NITToolBox.NITAutomaticGainControl()
        #self.player = NITLibrary.NITToolBox.NITPlayer("Player")
        self.dev << self.agc #<< self.player
        self.data_observer = DataObserver(self.data)
        self.agc << self.data_observer
        self.data['IRCamera.initialized'][0] = True
        
    def run(self):
        self.dev.start()	    #Start Capture
        logger.info('capture started')
        
        # for i in range(3):
        #     time.sleep(1)
        #     print(i)

        # self.stop()
        while True:
            time.sleep(0.1)

    def __del__(self):
        self.stop()

    def stop(self):

        self.dev.stop()      #Stop Capture
        logger.info('capture stopped')

        
        # Second Way
        #print("Second Way")
        #self.dev.captureNFrames( 100 )	# Capture 100 Frames
        #self.dev.waitEndCapture()	# Wait end of capture

        #Third Way
        #print("Third Way")
        #self.dev.captureForDuration( 5000 )    #Capture for 5 seconds (time in ms)
        #self.dev.waitEndCapture()	      #Wait end of capture


class ConfigObserver(NITLibrary.NITConfigObserver):
    def onParamChanged(self, param_name, str_value, num_value):
        logger.debug("onParamChanged(" + param_name + ", \"" + str_value + "\", "
                     + str(num_value) + ")")
        
    def onParamRangeChanged(self, param_name, str_values, num_values, array_size,
                            cur_str_val, cur_num_val ):
        logger.debug("onParamRangeChanged(" + param_name + ")")
        logger.debug("\tcurrent = \"" + cur_str_val + "\", " + str(cur_num_val))
        if(str_values):
            logger.debug("\tstr range = [\"" + str_values[0] + "\", \"" + str_values[-1] + "\"]" ) 
            logger.debug("\tnum range = [" + str(num_values[0]) + ", "
                         + str(num_values[-1]) + "]" )
            
    def onFpsChanged(self, new_fps):
        logger.debug("onFpsChanged(" + str(new_fps) + ")")
        
    def onFpsRangeChanged(self, new_fpsMin, new_fpsMax, new_fps ):
        logger.debug("onFpsRangeChanged(" + str(new_fpsMin) + ", "
                     + str(new_fpsMax) + ", "  + str(new_fps) + ")")
        
    def onNewFrame(self, status):
        #logger.debug("onNewFrame(" + str(status) + ")")
        pass
    
    def onNucChanged(self, nuc_str, status ):
        logger.debug("onNucChanged(" + nuc_str + ", " + str(status) + ")")

# class DataFilter(NITLibrary.NITUserFilter):
#     def onNewFrame(self, frame):   #You MUST define this function - It will be called on each frames
#         if(frame.pixelType() == NITLibrary.ePixType.FLOAT ):
#             new_array = 1.0 - frame.data() #frame.data() gives access to the first pixel
#         else :
#             new_array = np.invert(frame.data()) 
#         return new_array        #Don't forget to return the resulting array

class DataObserver(NITLibrary.NITUserObserver):

    
    def __init__(self, data):

        super().__init__()
        self.data = data
        self.times = np.full(1000, np.nan, dtype=float)
        self.ids = np.full_like(self.times, np.nan)
        self.last_frame_out_time = 0
        self.frame_out_period = 0.1 # s
        self.stats_last_index = 0
        
        
    def onNewFrame(self, frame):

        def write_out_frame(data, frame_data):
            #frame_data = frame_data.T.flatten()
            #self.data['IRCamera.last_frame'][:self.data['IRCamera.frame_size'].get()] = frame_data
            #print('done')
            pass

        
        try:
            index = int(frame.id()) - 1
            frame_time = time.time()
            self.times[index % self.times.size] = frame_time
            self.ids[index % self.times.size] = index

            if index > self.stats_last_index + self.times.size: # buffers were fulled
                self.stats_last_index = (index // self.times.size) * self.times.size
                diff_times = np.diff(self.times)
                diff_ids = np.diff(self.ids)
                logger.info(f'frame {index} median sampling time: {np.nanmedian(diff_times)}, {np.sum(diff_times==0)}, {np.sum(diff_times==0)}, {np.sum(diff_ids!=1)}')
                self.times.fill(np.nan)
                self.ids.fill(np.nan)

            
            
            
            
            if frame_time - self.last_frame_out_time > self.frame_out_period:
                self.last_frame_out_time = frame_time

                #print('yep')
                #p = multiprocessing.Process(target=write_out_frame, args=(self.data, frame.data()))
                #p.daemon = True  # Le processus sera tué si le programme principal se termine
                #p.start()
                frame_data = frame.data().T.flatten()
                self.data['IRCamera.last_frame'][:self.data['IRCamera.frame_size'][0]] = frame_data
                
                #with ProcessPoolExecutor() as executor:
                #    future = executor.submit(self.write_out_frame, frame.data())
                # si on veut ajouter un callback
                #future.add_done_callback(callback)  # Déclenche callback quand terminé
                #def callback(future):
                #    result = future.result()
                #    print(f"Callback exécuté : {result}")

    
        
        except Exception as e:
            logger.error('error:', e)


        
    
